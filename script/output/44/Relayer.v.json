{"language": "Solidity", "sources": {"src/eco/Relayer.sol": {"content": "// This file is part of Darwinia.\n// Copyright (C) 2018-2023 Darwinia Network\n// SPDX-License-Identifier: GPL-3.0\n//\n// Darwinia is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Darwinia is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Darwinia. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IEndpoint.sol\";\n\ncontract Relayer {\n    event Assigned(bytes32 indexed msgHash, uint256 fee, bytes params, bytes32[32] proof);\n    event SetDstPrice(uint256 indexed chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei);\n    event SetDstConfig(uint256 indexed chainId, uint64 baseGas, uint64 gasPerByte);\n    event SetApproved(address operator, bool approve);\n\n    struct DstPrice {\n        uint128 dstPriceRatio; // dstPrice / localPrice * 10^10\n        uint128 dstGasPriceInWei;\n    }\n\n    struct DstConfig {\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    address public immutable PROTOCOL;\n    address public owner;\n\n    // chainId => price\n    mapping(uint256 => DstPrice) public priceOf;\n    mapping(uint256 => DstConfig) public configOf;\n    mapping(address => bool) public approvedOf;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"!owner\");\n        _;\n    }\n\n    modifier onlyApproved() {\n        require(isApproved(msg.sender), \"!approve\");\n        _;\n    }\n\n    constructor(address dao, address ormp) {\n        PROTOCOL = ormp;\n        owner = dao;\n    }\n\n    receive() external payable {}\n\n    function changeOwner(address owner_) external onlyOwner {\n        owner = owner_;\n    }\n\n    function isApproved(address operator) public view returns (bool) {\n        return approvedOf[operator];\n    }\n\n    function setApproved(address operator, bool approve) public onlyOwner {\n        approvedOf[operator] = approve;\n        emit SetApproved(operator, approve);\n    }\n\n    function setDstPrice(uint256 chainId, uint128 dstPriceRatio, uint128 dstGasPriceInWei) external onlyApproved {\n        priceOf[chainId] = DstPrice(dstPriceRatio, dstGasPriceInWei);\n        emit SetDstPrice(chainId, dstPriceRatio, dstGasPriceInWei);\n    }\n\n    function setDstConfig(uint256 chainId, uint64 baseGas, uint64 gasPerByte) external onlyApproved {\n        configOf[chainId] = DstConfig(baseGas, gasPerByte);\n        emit SetDstConfig(chainId, baseGas, gasPerByte);\n    }\n\n    function withdraw(address to, uint256 amount) external onlyApproved {\n        (bool success,) = to.call{value: amount}(\"\");\n        require(success, \"!withdraw\");\n    }\n\n    // params = [extraGas]\n    function fee(uint256 toChainId, address, /*ua*/ uint256 size, bytes calldata params)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 extraGas = abi.decode(params, (uint256));\n        DstPrice memory p = priceOf[toChainId];\n        DstConfig memory c = configOf[toChainId];\n\n        // remoteToken = dstGasPriceInWei * (baseGas + extraGas)\n        uint256 remoteToken = p.dstGasPriceInWei * (c.baseGas + extraGas);\n        // dstPriceRatio = dstPrice / localPrice * 10^10\n        // sourceToken = RemoteToken * dstPriceRatio\n        uint256 sourceToken = remoteToken * p.dstPriceRatio / (10 ** 10);\n        uint256 payloadToken = c.gasPerByte * size * p.dstGasPriceInWei * p.dstPriceRatio / (10 ** 10);\n        return sourceToken + payloadToken;\n    }\n\n    function assign(bytes32 msgHash, bytes calldata params) external payable {\n        require(msg.sender == PROTOCOL, \"!ormp\");\n        emit Assigned(msgHash, msg.value, params, IEndpoint(PROTOCOL).prove());\n    }\n\n    function relay(Message calldata message, bytes calldata proof, uint256 gasLimit) external onlyApproved {\n        IEndpoint(PROTOCOL).recv(message, proof, gasLimit);\n    }\n}\n", "keccak256": "0xd2d9287842310aeb9c13e88130197519fd0151b4ed772a1b838a114d0ce589d4"}, "src/interfaces/IEndpoint.sol": {"content": "// This file is part of Darwinia.\n// Copyright (C) 2018-2023 Darwinia Network\n// SPDX-License-Identifier: GPL-3.0\n//\n// Darwinia is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Darwinia is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Darwinia. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.8.17;\n\nimport \"../Common.sol\";\n\ninterface IEndpoint {\n    /// @dev Send a cross-chain message over the endpoint.\n    /// @notice follow https://eips.ethereum.org/EIPS/eip-5750\n    /// @param toChainId The Message destination chain id.\n    /// @param to User application contract address which receive the message.\n    /// @param encoded The calldata which encoded by ABI Encoding.\n    /// @param params General extensibility for relayer to custom functionality.\n    /// @return Return the hash of the message as message id.\n    function send(uint256 toChainId, address to, bytes calldata encoded, bytes calldata params)\n        external\n        payable\n        returns (bytes32);\n\n    /// @notice Get a quote in source native gas, for the amount that send() requires to pay for message delivery.\n    /// @param toChainId The Message destination chain id.\n    //  @param to User application contract address which receive the message.\n    /// @param encoded The calldata which encoded by ABI Encoding.\n    /// @param params General extensibility for relayer to custom functionality.\n    function fee(uint256 toChainId, address, /*to*/ bytes calldata encoded, bytes calldata params)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Retry failed message.\n    /// @notice Only message.to could clear this message.\n    /// @param message Failed message info.\n    function clearFailedMessage(Message calldata message) external;\n\n    /// @dev Retry failed message.\n    /// @param message Failed message info.\n    /// @return dispatchResult Result of the message dispatch.\n    function retryFailedMessage(Message calldata message) external returns (bool dispatchResult);\n\n    /// @dev Recv verified message and dispatch to destination user application address.\n    /// @param message Verified receive message info.\n    /// @param proof Message proof of this message.\n    /// @param gasLimit The gas limit of message execute.\n    /// @return dispatchResult Result of the message dispatch.\n    function recv(Message calldata message, bytes calldata proof, uint256 gasLimit)\n        external\n        returns (bool dispatchResult);\n\n    function prove() external view returns (bytes32[32] memory);\n\n    /// @dev Fetch user application config.\n    /// @notice If user application has not configured, then the default config is used.\n    /// @param ua User application contract address.\n    /// @return user application config.\n    function getAppConfig(address ua) external view returns (Config memory);\n\n    /// @notice Set user application config.\n    /// @param oracle Oracle which user application choose.\n    /// @param relayer Relayer which user application choose.\n    function setAppConfig(address oracle, address relayer) external;\n\n    function setDefaultConfig(address oracle, address relayer) external;\n    function defaultConfig() external view returns (Config memory);\n    function changeSetter(address setter_) external;\n}\n", "keccak256": "0xd5ba6709e1b726d55feed98f05ad4756e6fa4f54c9c0aba0cb381c80eedcb13e"}, "src/Common.sol": {"content": "// This file is part of Darwinia.\n// Copyright (C) 2018-2023 Darwinia Network\n// SPDX-License-Identifier: GPL-3.0\n//\n// Darwinia is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Darwinia is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Darwinia. If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.8.17;\n\n/// @dev The block of control information and data for comminicate\n/// between user applications. Messages are the exchange medium\n/// used by channels to send and receive data through cross-chain networks.\n/// A message is sent from a source chain to a destination chain.\n/// @param index The leaf index lives in channel's incremental mekle tree.\n/// @param fromChainId The message source chain id.\n/// @param from User application contract address which send the message.\n/// @param toChainId The Message destination chain id.\n/// @param to User application contract address which receive the message.\n/// @param encoded The calldata which encoded by ABI Encoding.\nstruct Message {\n    address channel;\n    uint256 index;\n    uint256 fromChainId;\n    address from;\n    uint256 toChainId;\n    address to;\n    bytes encoded; /*(abi.encodePacked(SELECTOR, PARAMS))*/\n}\n\n/// @dev User application custom configuration.\n/// @param oracle Oracle contract address.\n/// @param relayer Relayer contract address.\nstruct Config {\n    address oracle;\n    address relayer;\n}\n\n/// @dev Hash of the message.\nfunction hash(Message memory message) pure returns (bytes32) {\n    return keccak256(abi.encode(message));\n}\n", "keccak256": "0x2979fa8e95d9123dda10ead653af13b188ef365dc12d405e545479c9d542954d"}}, "settings": {"remappings": ["forge-std/=lib/forge-std/src/", "ds-test/=lib/forge-std/lib/ds-test/src/"], "optimizer": {"enabled": true, "runs": 999999}, "metadata": {"useLiteralContent": false, "bytecodeHash": "none"}, "outputSelection": {"*": {"": ["ast"], "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata", "storageLayout", "devdoc", "userdoc"]}}, "evmVersion": "london", "libraries": {}, "compilationTarget": {"src/eco/Relayer.sol": "Relayer"}}}